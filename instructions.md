‚öôÔ∏è INSTRUCCIONES OBLIGATORIAS PARA ANTIGRAVITYPrompt:Contexto Primario:Est√°s trabajando en una SPA (Rechord) que gestiona canciones, letras y acordes para m√∫sicos. El proyecto debe ser altamente modular y con c√≥digo trazable.üìú RESUMEN DEL PROYECTO (Rechord)Rechord es una SPA para m√∫sicos que gestiona canciones, letras y acordes, permitiendo sincronizaci√≥n din√°mica tipo karaoke (Musixmatch). Usa una API REST en PHP/MySQL para usuarios, canciones, acordes, y gesti√≥n de archivos MP3. El objetivo es crear una herramienta funcional y modular para aprendizaje y creaci√≥n musical.üö® REGLAS DE OPERACI√ìN OBLIGATORIAS:Antes de cualquier respuesta o modificaci√≥n:Revisi√≥n de Contexto: Siempre consulta los archivos project_structure.json y db_schema.md para entender el estado actual del proyecto y la base de datos.La estructura DB actual reside en rechord.sql.Modularizaci√≥n y Longitud de C√≥digo (NUEVO):Ning√∫n archivo de c√≥digo (JS/TS, PHP, etc.) debe exceder las 200 l√≠neas.Si se supera este l√≠mite o se acerca, el archivo debe ser subdividido y modularizado en archivos m√°s peque√±os inmediatamente.Ejecuci√≥n: Actualizaci√≥n de Estructuras (OBLIGATORIO):Si creas, modificas o eliminas archivos: Debes actualizar el archivo project_structure.json para reflejar exactamente el nuevo √°rbol de directorios y archivos.Si creas, modificas o eliminas tablas o atributos en la DB: Debes actualizar el archivo db_schema.md con la sintaxis de Mermaid ERD para que refleje el nuevo esquema de la base de datos.Generaci√≥n de Migraci√≥n DB (NUEVO): Adem√°s de actualizar db_schema.md, debes generar un archivo SQL llamado db_migration_N.sql (donde N es un n√∫mero incremental) que contenga solo los ALTER TABLE o CREATE TABLE necesarios para actualizar la base de datos a su nuevo estado.Ejecuci√≥n: Gesti√≥n de Versiones (OBLIGATORIO):Despu√©s de cada conjunto de cambios: Debes generar la secuencia completa de comandos de Git.Secuencia de Git (OBLIGATORIA):git add .git commit -m "Mensaje descriptivo del cambio"git pushConfirmaci√≥n Final: Siempre termina tu respuesta con la secuencia de comandos de Git completa que se debe ejecutar y una breve confirmaci√≥n de que se han cumplido los pasos de actualizaci√≥n de estructura.üèõÔ∏è ESTRATEGIA DE ARQUITECTURA (ENFORCING MODULARITY)Todas las tareas de refactorizaci√≥n o desarrollo deben adherirse estrictamente a los siguientes principios de arquitectura para garantizar el desacoplamiento (loose coupling).1. Backend (PHP/API) - Principio de Separaci√≥n de ResponsabilidadesEl flujo de ejecuci√≥n debe ser: Router $\rightarrow$ Controller $\rightarrow$ Service $\rightarrow$ Model.Models (models/): Solo CRUD y mapeo DB. Estrictamente responsables de interactuar con MySQL (SQL, ORM, DTOs). Prohibida la l√≥gica de negocio.Controllers (controllers/): Solo gesti√≥n de HTTP. Deben ser lo m√°s delgados posible. Su √∫nica funci√≥n es:Validar la petici√≥n HTTP (par√°metros, autenticaci√≥n).Llamar a la capa de Services/Managers.Formatear la respuesta JSON.Services/Managers (NUEVA CAPA): Introduce una nueva carpeta backend/services/ (ej: CancionManager.php). Esta capa contiene toda la L√≥gica de Negocio y coordina el uso de m√∫ltiples modelos.Ejemplo: La l√≥gica para "Subir Canci√≥n y crear Metadatos de Home" debe vivir en un Service, no en el CancionController ni en Cancion.php.2. Frontend (Vanilla JS) - Principio de Desacoplamiento de EstadoEl estado de la aplicaci√≥n debe ser centralizado y los componentes deben ser agn√≥sticos entre s√≠.Gesti√≥n de Estado (Store): Implementar un patr√≥n Publicador-Subscriptor (Pub-Sub) o un Store simple en frontend/core/StateStore.js. Este archivo ser√° el √∫nico punto de verdad para el estado persistente (ej: Canci√≥n actual, Estado del reproductor, Tema de la interfaz, Datos de la sesi√≥n).Comunicaci√≥n entre Componentes:Los componentes (FolderSidebar.js, SongCard.js, PlayerControls.js) no deben llamarse directamente.Para cambiar el estado, deben publicar eventos en el StateStore. (Ej: Store.publish('PLAYER:SONG_LOAD', data)).Para reaccionar a los cambios, deben suscribirse a eventos del StateStore. (Ej: Store.subscribe('PLAYER:SONG_LOAD', renderNewSong)).Objetivo: La barra de reproducci√≥n (PlayerControls.js) debe reaccionar autom√°ticamente cuando cualquier componente haga clic en 'Play', sin saber qu√© componente emiti√≥ el evento.3. Implementaci√≥n de WebSockets (Sincronizaci√≥n de Reproductor)Para lograr la reproducci√≥n simult√°nea y sincronizada, se debe implementar una capa de comunicaci√≥n persistente mediante WebSockets.Tareas del Backend (PHP)Instalaci√≥n: Instalar una librer√≠a WebSocket PHP (como Ratchet) si el entorno lo permite, o definir un protocolo de servicio si se usa un servicio externo.Estructura de Carpeta: Crear backend/websocket/ para la l√≥gica del servidor persistente.Servicio Central: Crear backend/services/RoomManager.php que maneje la l√≥gica de las salas y los usuarios conectados.Tareas del Frontend (Vanilla JS)Estructura de Carpeta: Crear frontend/services/socketService.js para encapsular toda la l√≥gica de conexi√≥n WebSocket.Integraci√≥n de Estado: El StateStore.js debe manejar un nuevo estado: roomID y roomMembers.Reproductor Unificado: El PlayerControls.js y PlayerPage.js deben ser controlados por eventos que provienen del socket, no de clics locales, cuando est√°n en una sala.Confirmaci√≥n y Comandos GitSe ha actualizado el archivo instructions.md con la nueva Regla de Migraci√≥n de Base de Datos (generaci√≥n de db_migration_N.sql) y la secci√≥n de WebSockets.Bashgit add .
git commit -m "feat: Integradas reglas de migraci√≥n SQL y plan de arquitectura para WebSockets en instructions.md"
git push